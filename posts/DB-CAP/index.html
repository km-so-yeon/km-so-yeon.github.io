<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[DB] CAP 이론" /><meta name="author" content="김소연" /><meta property="og:locale" content="en" /><meta name="description" content="CAP 이론이란? CAP 정리에 의하면 데이터베이스 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있고 3가지 모두를 충족할 수는 없다는 이론이다. Consistency, Availablity를 합치면, CA 또는 Consistency와 Partition tolerance를 조합하면 AP가 된다. CAP에 대해 설명하기 앞서 용어에 대해 정리하자면, 분산 데이터베이스는 데이터를 여러 대의 노드에 저장한다. 노드란 데이터베이스 인스턴스를 구동하는 물리적인 서버이고, 각 노드는 다른 노드와 서로 통신한다. 일관성(Consistency) 일관성은 데이터를 저장하는 장비가 1대든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. ACID 원리에서 의미하는 Consistency와 같다. 가용성(Availablity) 가용성은 모든 요청이 응답을 받을 수 있어야 한다는 것을 의미한다. 사용자가 읽기 작업을 하든 쓰기 작업을 하든, 심지어 작업이 실패했더라도 사용자는 응답을 받을 수 있어야 한다. 즉, 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태여야 한다. 가용성은 사용자가 데이터가 일관되지 않더라도 언제든지 접근할 수 있다는 것을 의미한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다. 분할 허용성(Partition tolerance) 분할이란 노드 간 통신이 끊어지는 것을 의미한다. 즉, 한 노드가 다른 노드와 통신할 수 없을 때 분할이 생겼다고 한다. 분할 허용성은 노드가 여러 대 동작하고 있을 때, 해당 노드 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 사용자 요청에 응답할 수 있어야 한다. 이는 데이터의 복제본을 여러 다른 노드에 저장하여 처리하는 것을 의미한다. 따라서 분할이 생기더라도 복제본으로부터 데이터를 조회할 수 있다. 분할 허용성은 분산 데이터베이스 시스템에서 필수적이다. 예시 관계형 데이터베이스 : CA 시스템 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다. 관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다. 만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다. NoSQL 데이터베이스 : CP나 AP 시스템 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다. MongoDB : CP 시스템 MongoDB는 데이터를 하나 혹은 여러 개의 프라이머리 노드에 이진 JSON 형태로 저장한다. 각 프라이머리 노드는 로그를 이용해 비동기적으로 업데이트되는 복제본을 가진 여러 개의 세컨더리 노드를 가진다. 각 노드는 다른 모든 노드와 통신하여 서로의 상태를 확인한다. 만약 몇 초동안 응답을 받지 못하면 해당 노드는 접근 불가능한 상태로 지정된다. 프라이머리 노드가 중단되었다면 세컨더리 노드 중 하나가 프라이머리 노드로 승격되어야 한다. 새로운 프라이머리 노드가 선출되는 동안 시스템은 모든 쓰기 작업이 잠시 사용 불가능(unavailable)한 상태가 된다. (가용성 불가능) 따라서 MongoDB는 CP시스템으로 분류된다. Cassandra : AP 시스템 Cassandra는 Peer-to-Peer 시스템이다. 즉, 프라이머리 노드 없이 모든 노드가 읽기 작업과 쓰기 작업을 수행할 수 있고, 복제본을 분리된 다른 노드에 저장한다. 지정된 복제 수만큼 데이터를 시계 방향으로 인접한 노드에 복제한다. 한 노드가 통신에서 끊어졌다면, 여전히 읽기 쓰기 작업은 수행할 수 있으나 데이터가 다른 노드와 맞지 않는 상태, 즉 일관성이 깨진 상태가 된다. Cassandra는 이를 최종적 일관성(Eventual Consistency)를 통해 추후에 복구한다. 모든 노드 간 데이터가 동기화되기 전까지 각 노드는 서로 다른 버전의 데이터를 가지고 있다. 따라서 Cassandra는 일관성을 포기한 대신 높은 가용성을 확보한 AP시스템으로 분류된다. 출처 https://dongwooklee96.github.io/post/2021/03/26/cap-이론이란/ https://onduway.tistory.com/106" /><meta property="og:description" content="CAP 이론이란? CAP 정리에 의하면 데이터베이스 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있고 3가지 모두를 충족할 수는 없다는 이론이다. Consistency, Availablity를 합치면, CA 또는 Consistency와 Partition tolerance를 조합하면 AP가 된다. CAP에 대해 설명하기 앞서 용어에 대해 정리하자면, 분산 데이터베이스는 데이터를 여러 대의 노드에 저장한다. 노드란 데이터베이스 인스턴스를 구동하는 물리적인 서버이고, 각 노드는 다른 노드와 서로 통신한다. 일관성(Consistency) 일관성은 데이터를 저장하는 장비가 1대든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. ACID 원리에서 의미하는 Consistency와 같다. 가용성(Availablity) 가용성은 모든 요청이 응답을 받을 수 있어야 한다는 것을 의미한다. 사용자가 읽기 작업을 하든 쓰기 작업을 하든, 심지어 작업이 실패했더라도 사용자는 응답을 받을 수 있어야 한다. 즉, 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태여야 한다. 가용성은 사용자가 데이터가 일관되지 않더라도 언제든지 접근할 수 있다는 것을 의미한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다. 분할 허용성(Partition tolerance) 분할이란 노드 간 통신이 끊어지는 것을 의미한다. 즉, 한 노드가 다른 노드와 통신할 수 없을 때 분할이 생겼다고 한다. 분할 허용성은 노드가 여러 대 동작하고 있을 때, 해당 노드 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 사용자 요청에 응답할 수 있어야 한다. 이는 데이터의 복제본을 여러 다른 노드에 저장하여 처리하는 것을 의미한다. 따라서 분할이 생기더라도 복제본으로부터 데이터를 조회할 수 있다. 분할 허용성은 분산 데이터베이스 시스템에서 필수적이다. 예시 관계형 데이터베이스 : CA 시스템 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다. 관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다. 만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다. NoSQL 데이터베이스 : CP나 AP 시스템 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다. MongoDB : CP 시스템 MongoDB는 데이터를 하나 혹은 여러 개의 프라이머리 노드에 이진 JSON 형태로 저장한다. 각 프라이머리 노드는 로그를 이용해 비동기적으로 업데이트되는 복제본을 가진 여러 개의 세컨더리 노드를 가진다. 각 노드는 다른 모든 노드와 통신하여 서로의 상태를 확인한다. 만약 몇 초동안 응답을 받지 못하면 해당 노드는 접근 불가능한 상태로 지정된다. 프라이머리 노드가 중단되었다면 세컨더리 노드 중 하나가 프라이머리 노드로 승격되어야 한다. 새로운 프라이머리 노드가 선출되는 동안 시스템은 모든 쓰기 작업이 잠시 사용 불가능(unavailable)한 상태가 된다. (가용성 불가능) 따라서 MongoDB는 CP시스템으로 분류된다. Cassandra : AP 시스템 Cassandra는 Peer-to-Peer 시스템이다. 즉, 프라이머리 노드 없이 모든 노드가 읽기 작업과 쓰기 작업을 수행할 수 있고, 복제본을 분리된 다른 노드에 저장한다. 지정된 복제 수만큼 데이터를 시계 방향으로 인접한 노드에 복제한다. 한 노드가 통신에서 끊어졌다면, 여전히 읽기 쓰기 작업은 수행할 수 있으나 데이터가 다른 노드와 맞지 않는 상태, 즉 일관성이 깨진 상태가 된다. Cassandra는 이를 최종적 일관성(Eventual Consistency)를 통해 추후에 복구한다. 모든 노드 간 데이터가 동기화되기 전까지 각 노드는 서로 다른 버전의 데이터를 가지고 있다. 따라서 Cassandra는 일관성을 포기한 대신 높은 가용성을 확보한 AP시스템으로 분류된다. 출처 https://dongwooklee96.github.io/post/2021/03/26/cap-이론이란/ https://onduway.tistory.com/106" /><link rel="canonical" href="https://km-so-yeon.github.io/posts/DB-CAP/" /><meta property="og:url" content="https://km-so-yeon.github.io/posts/DB-CAP/" /><meta property="og:site_name" content="포스트잇" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-08-04T09:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[DB] CAP 이론" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@김소연" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"김소연"},"dateModified":"2023-08-04T09:00:00+09:00","datePublished":"2023-08-04T09:00:00+09:00","description":"CAP 이론이란? CAP 정리에 의하면 데이터베이스 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있고 3가지 모두를 충족할 수는 없다는 이론이다. Consistency, Availablity를 합치면, CA 또는 Consistency와 Partition tolerance를 조합하면 AP가 된다. CAP에 대해 설명하기 앞서 용어에 대해 정리하자면, 분산 데이터베이스는 데이터를 여러 대의 노드에 저장한다. 노드란 데이터베이스 인스턴스를 구동하는 물리적인 서버이고, 각 노드는 다른 노드와 서로 통신한다. 일관성(Consistency) 일관성은 데이터를 저장하는 장비가 1대든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. ACID 원리에서 의미하는 Consistency와 같다. 가용성(Availablity) 가용성은 모든 요청이 응답을 받을 수 있어야 한다는 것을 의미한다. 사용자가 읽기 작업을 하든 쓰기 작업을 하든, 심지어 작업이 실패했더라도 사용자는 응답을 받을 수 있어야 한다. 즉, 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태여야 한다. 가용성은 사용자가 데이터가 일관되지 않더라도 언제든지 접근할 수 있다는 것을 의미한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다. 분할 허용성(Partition tolerance) 분할이란 노드 간 통신이 끊어지는 것을 의미한다. 즉, 한 노드가 다른 노드와 통신할 수 없을 때 분할이 생겼다고 한다. 분할 허용성은 노드가 여러 대 동작하고 있을 때, 해당 노드 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 사용자 요청에 응답할 수 있어야 한다. 이는 데이터의 복제본을 여러 다른 노드에 저장하여 처리하는 것을 의미한다. 따라서 분할이 생기더라도 복제본으로부터 데이터를 조회할 수 있다. 분할 허용성은 분산 데이터베이스 시스템에서 필수적이다. 예시 관계형 데이터베이스 : CA 시스템 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다. 관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다. 만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다. NoSQL 데이터베이스 : CP나 AP 시스템 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다. MongoDB : CP 시스템 MongoDB는 데이터를 하나 혹은 여러 개의 프라이머리 노드에 이진 JSON 형태로 저장한다. 각 프라이머리 노드는 로그를 이용해 비동기적으로 업데이트되는 복제본을 가진 여러 개의 세컨더리 노드를 가진다. 각 노드는 다른 모든 노드와 통신하여 서로의 상태를 확인한다. 만약 몇 초동안 응답을 받지 못하면 해당 노드는 접근 불가능한 상태로 지정된다. 프라이머리 노드가 중단되었다면 세컨더리 노드 중 하나가 프라이머리 노드로 승격되어야 한다. 새로운 프라이머리 노드가 선출되는 동안 시스템은 모든 쓰기 작업이 잠시 사용 불가능(unavailable)한 상태가 된다. (가용성 불가능) 따라서 MongoDB는 CP시스템으로 분류된다. Cassandra : AP 시스템 Cassandra는 Peer-to-Peer 시스템이다. 즉, 프라이머리 노드 없이 모든 노드가 읽기 작업과 쓰기 작업을 수행할 수 있고, 복제본을 분리된 다른 노드에 저장한다. 지정된 복제 수만큼 데이터를 시계 방향으로 인접한 노드에 복제한다. 한 노드가 통신에서 끊어졌다면, 여전히 읽기 쓰기 작업은 수행할 수 있으나 데이터가 다른 노드와 맞지 않는 상태, 즉 일관성이 깨진 상태가 된다. Cassandra는 이를 최종적 일관성(Eventual Consistency)를 통해 추후에 복구한다. 모든 노드 간 데이터가 동기화되기 전까지 각 노드는 서로 다른 버전의 데이터를 가지고 있다. 따라서 Cassandra는 일관성을 포기한 대신 높은 가용성을 확보한 AP시스템으로 분류된다. 출처 https://dongwooklee96.github.io/post/2021/03/26/cap-이론이란/ https://onduway.tistory.com/106","headline":"[DB] CAP 이론","mainEntityOfPage":{"@type":"WebPage","@id":"https://km-so-yeon.github.io/posts/DB-CAP/"},"url":"https://km-so-yeon.github.io/posts/DB-CAP/"}</script><title>[DB] CAP 이론 | 포스트잇</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="포스트잇"><meta name="application-name" content="포스트잇"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">포스트잇</a></div><div class="site-subtitle font-italic">오늘보다 나은</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/km-so-yeon" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[DB] CAP 이론</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[DB] CAP 이론</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 김소연 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Aug 4, 2023, 9:00 AM +0900" >Aug 4<i class="unloaded">2023-08-04T09:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1499 words">8 min read</span></div></div><div class="post-content"><h2 id="cap-이론이란">CAP 이론이란?</h2><p>CAP 정리에 의하면 데이터베이스 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있고 3가지 모두를 충족할 수는 없다는 이론이다. Consistency, Availablity를 합치면, CA 또는 Consistency와 Partition tolerance를 조합하면 AP가 된다.</p><p>CAP에 대해 설명하기 앞서 용어에 대해 정리하자면, 분산 데이터베이스는 데이터를 여러 대의 노드에 저장한다. 노드란 데이터베이스 인스턴스를 구동하는 물리적인 서버이고, 각 노드는 다른 노드와 서로 통신한다.</p><h3 id="일관성consistency">일관성(Consistency)</h3><ul><li>일관성은 데이터를 저장하는 장비가 1대든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다.<li>ACID 원리에서 의미하는 Consistency와 같다.</ul><h3 id="가용성availablity">가용성(Availablity)</h3><ul><li>가용성은 모든 요청이 응답을 받을 수 있어야 한다는 것을 의미한다. 사용자가 읽기 작업을 하든 쓰기 작업을 하든, 심지어 작업이 실패했더라도 사용자는 응답을 받을 수 있어야 한다.<li>즉, 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태여야 한다.<li>가용성은 사용자가 데이터가 일관되지 않더라도 언제든지 접근할 수 있다는 것을 의미한다.<li>현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다.</ul><h3 id="분할-허용성partition-tolerance">분할 허용성(Partition tolerance)</h3><ul><li>분할이란 노드 간 통신이 끊어지는 것을 의미한다. 즉, 한 노드가 다른 노드와 통신할 수 없을 때 분할이 생겼다고 한다.<li>분할 허용성은 노드가 여러 대 동작하고 있을 때, 해당 노드 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 사용자 요청에 응답할 수 있어야 한다.<li>이는 데이터의 복제본을 여러 다른 노드에 저장하여 처리하는 것을 의미한다. 따라서 분할이 생기더라도 복제본으로부터 데이터를 조회할 수 있다.<li>분할 허용성은 분산 데이터베이스 시스템에서 필수적이다.</ul><h2 id="예시">예시</h2><h3 id="관계형-데이터베이스--ca-시스템">관계형 데이터베이스 : CA 시스템</h3><ul><li>일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다.<li>관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다. 만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다.</ul><h3 id="nosql-데이터베이스--cp나-ap-시스템">NoSQL 데이터베이스 : CP나 AP 시스템</h3><ul><li>대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다.<li>C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다.</ul><h4 id="mongodb--cp-시스템">MongoDB : CP 시스템</h4><p>MongoDB는 데이터를 하나 혹은 여러 개의 프라이머리 노드에 이진 JSON 형태로 저장한다.</p><p>각 프라이머리 노드는 로그를 이용해 비동기적으로 업데이트되는 복제본을 가진 여러 개의 세컨더리 노드를 가진다. 각 노드는 다른 모든 노드와 통신하여 서로의 상태를 확인한다.</p><p>만약 몇 초동안 응답을 받지 못하면 해당 노드는 접근 불가능한 상태로 지정된다. 프라이머리 노드가 중단되었다면 세컨더리 노드 중 하나가 프라이머리 노드로 승격되어야 한다. 새로운 프라이머리 노드가 선출되는 동안 시스템은 <strong>모든 쓰기 작업이 잠시 사용 불가능(unavailable)한 상태</strong>가 된다. (가용성 불가능)</p><p>따라서 MongoDB는 CP시스템으로 분류된다.</p><h4 id="cassandra--ap-시스템">Cassandra : AP 시스템</h4><p>Cassandra는 Peer-to-Peer 시스템이다.</p><p>즉, 프라이머리 노드 없이 모든 노드가 읽기 작업과 쓰기 작업을 수행할 수 있고, 복제본을 분리된 다른 노드에 저장한다. 지정된 복제 수만큼 데이터를 시계 방향으로 인접한 노드에 복제한다.</p><p>한 노드가 통신에서 끊어졌다면, 여전히 읽기 쓰기 작업은 수행할 수 있으나 데이터가 다른 노드와 맞지 않는 상태, 즉 일관성이 깨진 상태가 된다. Cassandra는 이를 최종적 일관성(Eventual Consistency)를 통해 추후에 복구한다. 모든 노드 간 데이터가 동기화되기 전까지 각 노드는 서로 다른 버전의 데이터를 가지고 있다.</p><p>따라서 Cassandra는 일관성을 포기한 대신 높은 가용성을 확보한 AP시스템으로 분류된다.</p><h2 id="출처">출처</h2><ul><li>https://dongwooklee96.github.io/post/2021/03/26/cap-이론이란/<li>https://onduway.tistory.com/106</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/db/'>DB</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/db/" class="post-tag no-text-decoration" >DB</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[DB] CAP 이론 - 포스트잇&url=https://km-so-yeon.github.io/posts/DB-CAP/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[DB] CAP 이론 - 포스트잇&u=https://km-so-yeon.github.io/posts/DB-CAP/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[DB] CAP 이론 - 포스트잇&url=https://km-so-yeon.github.io/posts/DB-CAP/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Web-Jwt/">[Web] JWT</a><li><a href="/posts/Spring-ApplicationContext/">[Spring] ApplicationContext의 구현체</a><li><a href="/posts/Language-Lambda-Stream/">[Java] 람다(Lambda) 표현식과 스트림(Stream)</a><li><a href="/posts/CS-Design-Pattern-Structural/">[CS] 디자인패턴 - 구조패턴</a><li><a href="/posts/CS-Design-Pattern-Creational/">[CS] 디자인패턴 - 생성패턴</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/javascript/">Javascript</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/cookie/">Cookie</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/AWS-SAA/"><div class="card-body"> <span class="timeago small" >Nov 15<i class="unloaded">2023-11-15T09:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[AWS] AWS SAA 합격 후기</h3><div class="text-muted small"><p> 응시하게 된 이유 지난 1년간 이직을 준비하면서 여러 면접에 탈락하면서 좌절감이 조금 있었다. 그래서 한 동안 휴식을 하면서 회복을 했지만 어딘가에서 성취감을 얻고 싶었고 최근 많이 사용하는 AWS 클라우드의 자격증을 응시하고자 하였다. 시험 신청 한국어로 선택하고 시험 신청 후 편의 지원 요청을 통해 추가 시간 30분도 받았다. 한국어로 ...</p></div></div></a></div><div class="card"> <a href="/posts/Filter,-Interceptor,-AOP/"><div class="card-body"> <span class="timeago small" >Nov 7<i class="unloaded">2023-11-07T09:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Java] Filter, Interceptor, AOP 비교</h3><div class="text-muted small"><p> 자바 웹 개발을 할 때 공통 처리를 위해 Filter, Interceptor, AOP를 활용할 수 있다. Filter, Interceptor, AOP 흐름 실행 순서 Filter → Interceptor → AOP → Interceptor → Filter 비교 Filter, Interceptor는 Servlet 단위에서 실행되고, A...</p></div></div></a></div><div class="card"> <a href="/posts/Web-Jwt/"><div class="card-body"> <span class="timeago small" >Oct 23<i class="unloaded">2023-10-23T05:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Web] JWT</h3><div class="text-muted small"><p> 배경 HTTP 프로토콜 통신은 모든 응답이 완료되면 끊어진 상태과 되는 비연결성과, 클라이언트 측의 상태를 보관하지 않는 무상태성(Stateless)의 특징을 가진다. 그러나 클라이언트의 정보가 계속해서 쓰여야하는 경우가 있다. 예를 들어 로그인을 진행한 후 다른 서비스를 진행할 때, 로그인 정보가 어딘가에 담겨있지 않다면 매번 로그인을 해야 한다...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/OS-Race-condition/" class="btn btn-outline-primary" prompt="Older"><p>[OS] Race condition 경쟁상태</p></a> <a href="/posts/DB-Propagation-Isolation/" class="btn btn-outline-primary" prompt="Newer"><p>[Spring] @Transactional - Propagation, Isolation</p></a></div><script src="https://utteranc.es/client.js" repo="km-so-yeon/km-so-yeon.github.io" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">김소연</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/javascript/">Javascript</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/cookie/">Cookie</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://km-so-yeon.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
